
==================== Output Cmm ====================
2019-12-24 13:23:29.666399 UTC

[]


==================== Output Cmm ====================
2019-12-24 13:23:29.667014 UTC

[section ""data" . Main.fib1_closure" {
     Main.fib1_closure:
         const GHC.Integer.Type.S#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2019-12-24 13:23:29.667322 UTC

[section ""data" . Main.fib3_closure" {
     Main.fib3_closure:
         const GHC.Integer.Type.S#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2019-12-24 13:23:29.667558 UTC

[section ""data" . Main.fib2_closure" {
     Main.fib2_closure:
         const GHC.Integer.Type.S#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2019-12-24 13:23:29.668234 UTC

[section ""data" . u4uh_srt" {
     u4uh_srt:
         const stg_SRT_1_info;
         const GHC.Integer.Type.plusInteger_closure;
         const 0;
 },
 Main.fib_fib_entry() //  [R2]
         { info_tbls: [(c4ty,
                        label: block_c4ty_info
                        rep: StackRep [False]
                        srt: Just Main.fib_fib_closure),
                       (c4tD,
                        label: Main.fib_fib_info
                        rep: HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} }
                        srt: Nothing),
                       (c4tI,
                        label: block_c4tI_info
                        rep: StackRep [False]
                        srt: Just Main.fib_fib_closure),
                       (c4tN,
                        label: block_c4tN_info
                        rep: StackRep [False]
                        srt: Just Main.fib_fib_closure),
                       (c4tR,
                        label: block_c4tR_info
                        rep: StackRep [False]
                        srt: Just Main.fib_fib_closure),
                       (c4tV,
                        label: block_c4tV_info
                        rep: StackRep [False]
                        srt: Just Main.fib_fib_closure),
                       (c4tZ,
                        label: block_c4tZ_info
                        rep: StackRep [False]
                        srt: Just u4uh_srt)]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4tD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tE; else goto c4tF;
       c4tE: // global
           R2 = R2;
           R1 = Main.fib_fib_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tF: // global
           I64[Sp - 16] = c4ty;
           R3 = Main.fib1_closure+1;
           _s4sS::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s4sS::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.eqInteger#_info(R3,
                                                 R2) returns to c4ty, args: 8, res: 8, upd: 8;
       c4ty: // global
           if (R1 != 1) goto c4tB; else goto c4tC;
       c4tB: // global
           I64[Sp] = c4tI;
           R3 = Main.fib3_closure+1;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.eqInteger#_info(R3,
                                                 R2) returns to c4tI, args: 8, res: 8, upd: 8;
       c4tI: // global
           if (R1 != 1) goto c4u2; else goto c4ud;
       c4u2: // global
           I64[Sp] = c4tN;
           R3 = Main.fib2_closure+1;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.minusInteger_info(R3,
                                                   R2) returns to c4tN, args: 8, res: 8, upd: 8;
       c4tN: // global
           I64[Sp] = c4tR;
           R2 = R1;
           call Main.fib_fib_info(R2) returns to c4tR, args: 8, res: 8, upd: 8;
       c4tR: // global
           I64[Sp] = c4tV;
           R3 = Main.fib3_closure+1;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.minusInteger_info(R3,
                                                   R2) returns to c4tV, args: 8, res: 8, upd: 8;
       c4tV: // global
           I64[Sp] = c4tZ;
           R2 = R1;
           call Main.fib_fib_info(R2) returns to c4tZ, args: 8, res: 8, upd: 8;
       c4tZ: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.plusInteger_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       c4ud: // global
           R1 = Main.fib3_closure+1;
           Sp = Sp + 16;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       c4tC: // global
           R1 = Main.fib1_closure+1;
           Sp = Sp + 16;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Main.fib_fib_closure" {
     Main.fib_fib_closure:
         const Main.fib_fib_info;
         const GHC.Integer.Type.minusInteger_closure;
         const u4uh_srt;
         const 0;
 }]


==================== Output Cmm ====================
2019-12-24 13:23:29.670703 UTC

[lvl_s4t3_entry() //  [R1]
         { info_tbls: [(c4uB,
                        label: lvl_s4t3_info
                        rep: HeapRep 1 ptrs { Thunk }
                        srt: Nothing)]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4uB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4uC; else goto c4uD;
       c4uC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4uD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Main.fib3_closure+1;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_info(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl1_s4t4_entry() //  [R1]
         { info_tbls: [(c4uI,
                        label: lvl1_s4t4_info
                        rep: HeapRep 1 ptrs { Thunk }
                        srt: Nothing)]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4uI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4uJ; else goto c4uK;
       c4uJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4uK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Main.fib2_closure+1;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_info(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl2_s4t5_entry() //  [R1]
         { info_tbls: [(c4uP,
                        label: lvl2_s4t5_info
                        rep: HeapRep 1 ptrs { Thunk }
                        srt: Nothing)]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4uP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4uQ; else goto c4uR;
       c4uQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4uR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Main.fib3_closure+1;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_info(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl3_s4t6_entry() //  [R1]
         { info_tbls: [(c4uW,
                        label: lvl3_s4t6_info
                        rep: HeapRep 1 ptrs { Thunk }
                        srt: Nothing)]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4uW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4uX; else goto c4uY;
       c4uX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4uY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Main.fib1_closure+1;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_info(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl4_s4t7_entry() //  [R1]
         { info_tbls: [(c4v3,
                        label: lvl4_s4t7_info
                        rep: HeapRep 1 ptrs { Thunk }
                        srt: Nothing)]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4v3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4v4; else goto c4v5;
       c4v4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4v5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Main.fib1_closure+1;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_info(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s4te_entry() //  [R1]
         { info_tbls: [(c4vr,
                        label: sat_s4te_info
                        rep: HeapRep 3 ptrs { Thunk }
                        srt: Nothing)]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4vr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4vs; else goto c4vt;
       c4vs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4vt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.-_info(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s4tf_entry() //  [R1]
         { info_tbls: [(c4vu,
                        label: sat_s4tf_info
                        rep: HeapRep 4 ptrs { Thunk }
                        srt: Nothing)]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4vu: // global
           _s4tf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4vv; else goto c4vw;
       c4vw: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4vy; else goto c4vx;
       c4vy: // global
           HpAlloc = 40;
           goto c4vv;
       c4vv: // global
           R1 = _s4tf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4vx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4tf::P64;
           _s4t0::P64 = P64[_s4tf::P64 + 16];
           _s4t4::P64 = P64[_s4tf::P64 + 24];
           _s4t8::P64 = P64[_s4tf::P64 + 32];
           _s4t9::P64 = P64[_s4tf::P64 + 40];
           I64[Hp - 32] = sat_s4te_info;
           P64[Hp - 16] = _s4t0::P64;
           P64[Hp - 8] = _s4t4::P64;
           P64[Hp] = _s4t9::P64;
           R2 = Hp - 32;
           R1 = _s4t8::P64;
           Sp = Sp - 16;
           call fib4_s4t8_info(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4tc_entry() //  [R1]
         { info_tbls: [(c4vH,
                        label: sat_s4tc_info
                        rep: HeapRep 3 ptrs { Thunk }
                        srt: Nothing)]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4vH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4vI; else goto c4vJ;
       c4vI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4vJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.-_info(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s4td_entry() //  [R1]
         { info_tbls: [(c4vK,
                        label: sat_s4td_info
                        rep: HeapRep 4 ptrs { Thunk }
                        srt: Nothing)]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4vK: // global
           _s4td::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4vL; else goto c4vM;
       c4vM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4vO; else goto c4vN;
       c4vO: // global
           HpAlloc = 40;
           goto c4vL;
       c4vL: // global
           R1 = _s4td::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4vN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4td::P64;
           _s4t0::P64 = P64[_s4td::P64 + 16];
           _s4t3::P64 = P64[_s4td::P64 + 24];
           _s4t8::P64 = P64[_s4td::P64 + 32];
           _s4t9::P64 = P64[_s4td::P64 + 40];
           I64[Hp - 32] = sat_s4tc_info;
           P64[Hp - 16] = _s4t0::P64;
           P64[Hp - 8] = _s4t3::P64;
           P64[Hp] = _s4t9::P64;
           R2 = Hp - 32;
           R1 = _s4t8::P64;
           Sp = Sp - 16;
           call fib4_s4t8_info(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 fib4_s4t8_entry() //  [R2, R1]
         { info_tbls: [(c4vb,
                        label: block_c4vb_info
                        rep: StackRep [False, False, False, False, False, False, False,
                                       False, False]
                        srt: Nothing),
                       (c4vf,
                        label: block_c4vf_info
                        rep: StackRep [False, False, False, False, False, True, False,
                                       False]
                        srt: Nothing),
                       (c4vT,
                        label: fib4_s4t8_info
                        rep: HeapRep 8 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} }
                        srt: Nothing)]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4vT: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c4vU; else goto c4vV;
       c4vU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4vV: // global
           I64[Sp - 80] = c4vb;
           R3 = P64[R1 + 63];
           _s4t9::P64 = R2;
           R2 = R2;
           _s4t8::P64 = R1;
           _s4sZ::P64 = P64[R1 + 7];
           _s4t0::P64 = P64[R1 + 15];
           _s4t1::P64 = P64[R1 + 23];
           _s4t3::P64 = P64[R1 + 31];
           _s4t4::P64 = P64[R1 + 39];
           _s4t5::P64 = P64[R1 + 47];
           _s4t6::P64 = P64[R1 + 55];
           R1 = _s4sZ::P64;
           P64[Sp - 72] = _s4sZ::P64;
           P64[Sp - 64] = _s4t0::P64;
           P64[Sp - 56] = _s4t1::P64;
           P64[Sp - 48] = _s4t3::P64;
           P64[Sp - 40] = _s4t4::P64;
           P64[Sp - 32] = _s4t5::P64;
           P64[Sp - 24] = _s4t6::P64;
           P64[Sp - 16] = _s4t8::P64;
           P64[Sp - 8] = _s4t9::P64;
           Sp = Sp - 80;
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) returns to c4vb, args: 8, res: 8, upd: 8;
       c4vb: // global
           if (R1 & 7 != 1) goto c4vR; else goto c4vQ;
       c4vR: // global
           R1 = P64[Sp + 56];
           Sp = Sp + 80;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4vQ: // global
           _s4sZ::P64 = P64[Sp + 8];
           I64[Sp + 8] = c4vf;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 72];
           R1 = _s4sZ::P64;
           Sp = Sp + 8;
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) returns to c4vf, args: 8, res: 8, upd: 8;
       c4vf: // global
           if (R1 & 7 != 1) goto c4w5; else goto c4vY;
       c4w5: // global
           R1 = P64[Sp + 40];
           Sp = Sp + 72;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4vY: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4w1; else goto c4w0;
       c4w1: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to c4vf, args: 8, res: 8, upd: 8;
       c4w0: // global
           I64[Hp - 88] = sat_s4tf_info;
           _s4t0::P64 = P64[Sp + 8];
           P64[Hp - 72] = _s4t0::P64;
           P64[Hp - 64] = P64[Sp + 32];
           _s4t8::P64 = P64[Sp + 56];
           P64[Hp - 56] = _s4t8::P64;
           _s4t9::P64 = P64[Sp + 64];
           P64[Hp - 48] = _s4t9::P64;
           I64[Hp - 40] = sat_s4td_info;
           P64[Hp - 24] = _s4t0::P64;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _s4t8::P64;
           P64[Hp] = _s4t9::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 48] = stg_ap_pp_info;
           P64[Sp + 56] = Hp - 40;
           P64[Sp + 64] = Hp - 88;
           Sp = Sp + 48;
           call GHC.Num.+_info(R2) args: 32, res: 0, upd: 8;
     }
 },
 Main.$wfib_entry() //  [R5, R4, R3, R2]
         { info_tbls: [(c4wa,
                        label: Main.$wfib_info
                        rep: HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} }
                        srt: Nothing)]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4wa: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto c4we; else goto c4wd;
       c4we: // global
           HpAlloc = 192;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Main.$wfib_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wd: // global
           I64[Hp - 184] = lvl_s4t3_info;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = lvl1_s4t4_info;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = lvl2_s4t5_info;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = lvl3_s4t6_info;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = lvl4_s4t7_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = fib4_s4t8_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = Hp - 184;
           P64[Hp - 24] = Hp - 160;
           P64[Hp - 16] = Hp - 136;
           P64[Hp - 8] = Hp - 112;
           P64[Hp] = Hp - 88;
           R2 = R5;
           R1 = Hp - 63;
           call fib4_s4t8_info(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Main.$wfib_closure" {
     Main.$wfib_closure:
         const Main.$wfib_info;
 }]


==================== Output Cmm ====================
2019-12-24 13:23:29.675914 UTC

[Main.fib_entry() //  [R5, R4, R3, R2]
         { info_tbls: [(c4xF,
                        label: block_c4xF_info
                        rep: StackRep [False, False, False]
                        srt: Nothing),
                       (c4xI,
                        label: Main.fib_info
                        rep: HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} }
                        srt: Nothing)]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4xI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4xJ; else goto c4xK;
       c4xJ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Main.fib_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xK: // global
           I64[Sp - 32] = c4xF;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto c4xF; else goto c4xG;
       c4xG: // global
           call (I64[R1])(R1) returns to c4xF, args: 8, res: 8, upd: 8;
       c4xF: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 32;
           call Main.$wfib_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Main.fib_closure" {
     Main.fib_closure:
         const Main.fib_info;
 }]


==================== Output Cmm ====================
2019-12-24 13:23:29.676702 UTC

[section ""data" . Main.main2_closure" {
     Main.main2_closure:
         const GHC.Integer.Type.S#_con_info;
         const 42;
 }]


==================== Output Cmm ====================
2019-12-24 13:23:29.677194 UTC

[section ""data" . u4ye_srt" {
     u4ye_srt:
         const stg_SRT_1_info;
         const GHC.Show.$w$cshowsPrec4_closure;
         const 0;
 },
 section ""data" . u4yf_srt" {
     u4yf_srt:
         const stg_SRT_2_info;
         const Main.fib_fib_closure;
         const u4ye_srt;
         const 0;
 },
 Main.main1_entry() //  [R1]
         { info_tbls: [(c4y0,
                        label: block_c4y0_info
                        rep: StackRep []
                        srt: Just u4ye_srt),
                       (c4y2,
                        label: Main.main1_info
                        rep: HeapRep static { Thunk }
                        srt: Just u4yf_srt),
                       (c4y5,
                        label: block_c4y5_info
                        rep: StackRep []
                        srt: Nothing)]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4y2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4y8; else goto c4y9;
       c4y8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4y9: // global
           (_c4xX::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4xX::I64 == 0) goto c4xZ; else goto c4xY;
       c4xZ: // global
           call (I64[R1])() args: 8, res: 0, upd: 8;
       c4xY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4xX::I64;
           I64[Sp - 24] = c4y0;
           R2 = Main.main2_closure+1;
           Sp = Sp - 24;
           call Main.fib_fib_info(R2) returns to c4y0, args: 8, res: 8, upd: 24;
       c4y0: // global
           I64[Sp] = c4y5;
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           call GHC.Show.$w$cshowsPrec4_info(R4,
                                             R3,
                                             R2) returns to c4y5, args: 8, res: 8, upd: 24;
       c4y5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4yd; else goto c4yc;
       c4yd: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to c4y5, args: 8, res: 8, upd: 24;
       c4yc: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""data" . Main.main1_closure" {
     Main.main1_closure:
         const Main.main1_info;
         const 0;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2019-12-24 13:23:29.678325 UTC

[Main.main_entry() //  []
         { info_tbls: [(c4yv,
                        label: Main.main_info
                        rep: HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} }
                        srt: Nothing)]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4yv: // global
           R4 = GHC.Types.True_closure+2;
           R3 = Main.main1_closure;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           call GHC.IO.Handle.Text.hPutStr'_info(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Main.main_closure" {
     Main.main_closure:
         const Main.main_info;
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.IO.Handle.Text.hPutStr'_closure;
         const Main.main1_closure;
         const 0;
 }]


==================== Output Cmm ====================
2019-12-24 13:23:29.678805 UTC

[Main.main3_entry() //  []
         { info_tbls: [(c4yF,
                        label: Main.main3_info
                        rep: HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} }
                        srt: Nothing)]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4yF: // global
           R2 = Main.main_closure+1;
           call GHC.TopHandler.runMainIO1_info(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Main.main3_closure" {
     Main.main3_closure:
         const Main.main3_info;
         const Main.main_closure;
         const GHC.TopHandler.runMainIO1_closure;
         const 0;
 }]


==================== Output Cmm ====================
2019-12-24 13:23:29.679297 UTC

[:Main.main_entry() //  []
         { info_tbls: [(c4yP,
                        label: :Main.main_info
                        rep: HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} }
                        srt: Just Main.main3_closure)]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       c4yP: // global
           call Main.main3_info() args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . :Main.main_closure" {
     :Main.main_closure:
         const :Main.main_info;
         const 0;
 }]


==================== Output Cmm ====================
2019-12-24 13:23:29.679658 UTC

[section ""cstring" . Main.$trModule4_bytes" {
     Main.$trModule4_bytes:
         I8[] [109,97,105,110]
 }]


==================== Output Cmm ====================
2019-12-24 13:23:29.679887 UTC

[section ""data" . Main.$trModule3_closure" {
     Main.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Main.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2019-12-24 13:23:29.680101 UTC

[section ""cstring" . Main.$trModule2_bytes" {
     Main.$trModule2_bytes:
         I8[] [77,97,105,110]
 }]


==================== Output Cmm ====================
2019-12-24 13:23:29.680311 UTC

[section ""data" . Main.$trModule1_closure" {
     Main.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Main.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2019-12-24 13:23:29.680528 UTC

[section ""data" . Main.$trModule_closure" {
     Main.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Main.$trModule3_closure+1;
         const Main.$trModule1_closure+1;
         const 3;
 }]
