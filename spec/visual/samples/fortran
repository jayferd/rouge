! vim: set ts=4 sw=4 et ft=fortran:

module rats

    type rational
        sequence
        integer :: numerator
        integer :: denominator
    end type rational

    interface operator(+)
        module procedure rat_add
    end interface

    interface operator(-)
        module procedure rat_sub
    end interface

    interface operator (*)
        module procedure rat_mul
    end interface

    interface operator(/)
        module procedure rat_div
    end interface

contains

    integer function gcd(a, b)
        integer, intent(in) :: a, b
        integer :: j, k, t

        j = a; k = b

        do while (k /= 0)
            t = mod(j, k)
            j = k
            k = t
        end do

        gcd = a
    end function gcd

    integer function lcm(a, b)
        integer, intent(in) :: a, b
        lcm = abs(a * b) / gcd(a, b)
    end function lcm

    type(rational) function rat_normalize(q)
        type(rational), intent(in) :: q
        integer :: n

        n = gcd(abs(q%numerator), abs(q%denominator))
        rat_normalize%numerator = sign(q%numerator / n, sign(1, q%numerator) * sign(1, q%denominator))
        rat_normalize%denominator = q%denominator / n
    end function rat_normalize

    integer function rat_numerator(q)
        type(rational), intent(in) :: q
        rat_numerator = q%numerator
    end function rat_numerator

    integer function rat_denominator(q)
        type(rational), intent(in) :: q
        rat_denominator =q%denominator
    end function rat_denominator

    type(rational) function rat_add(r, q)
        type(rational), intent(in) :: r, q
        integer :: n

        n = lcm(r%denominator, q%denominator)
        rat_add%numerator = (n / r%denominator) * r%numerator + (n / q%denominator) * q%numerator
        rat_add%denominator = n

        rat_add = rat_normalize(rat_add)
    end function rat_add

    type(rational) function rat_sub(r, q)
        type(rational), intent(in) :: r, q
        rat_sub = r + rational(- q%numerator, q%denominator)
    end function rat_sub

    type(rational) function rat_mul(r, q)
        type(rational), intent(in) :: r, q

        rat_mul%numerator = r%numerator * q%numerator
        rat_mul%denominator = r%denominator * q%denominator

        rat_mul = rat_normalize(rat_mul)
    end function rat_mul

    type(rational) function rat_div(r, q)
        type(rational), intent(in) :: r, q
        rat_div = r * rational(q%denominator, q%numerator)
    end function rat_div

end module rats

program bottles
    use rats
    implicit none

    character(20), parameter :: towels = 'Don''t Panic!'
    integer :: nbottles = 99
    type(rational) :: r = rational(1, 2), q = rational(1, 6)

    do while (nbottles > 0)
        call print_bottles(nbottles)
        nbottles = nbottles - 1
    end do

    print *, towels

    r = r - q
    write(*, '(I0, "/", I0)') rat_numerator(r), rat_denominator(r)

contains

    subroutine print_bottles(n)
        implicit none
        integer, intent(in) :: n

#if defined(VERBOSE)
        select case (n)
        case (2)
            write(*, 100) n
            write(*, 110) n
            write(*, 120)
            write(*, 230)
        case (1)
            write(*, 200)
            write(*, 210)
            write(*, 120)
            write(*, 330)
        case default
            write(*, 100) n
            write(*, 110) n
            write(*, 120)
            write(*, 130) n - 1
        end select

100     format (I0, 1X, 'bottles of beer on the wall,')
110     format (I0, 1X, 'bottles of beer.')
120     format ('Take one down, pass it around,')
130     format (I0, 1X, 'bottles of beer on the wall.', /)
200     format ('One last bottle of beer on the wall,')
210     format ('one last bottle of beer.')
230     format ('one last bottle of beer on the wall.', /)
330     format ('no more bottles of beer on the wall.', /)
#endif

    end subroutine print_bottles

    subroutine share_bottles(n, m)
      use, intrinsic :: ieee_arithmetic
      implicit none
      integer, intent(in) :: n, m

      double precision :: double
      doubleprecision  :: another_double

      if (m == 0) then
        double = ieee_value(double, IEEE_QUIET_NAN)
      else
        double = real(n, kind(double)) / real(m, kind(another_double))
        print '(A,F0.2,A)', 'Everyone gets ', double, ' bottles!'
      endif
    end subroutine share_bottles

end program bottles

module openmp_various_examples
contains

SUBROUTINE REDUCTION2(A, B, C, D, X, Y, N)
    REAL :: X(*), A, D
    INTEGER :: Y(*), N, B, C
    REAL :: A_P, D_P
    INTEGER :: I, B_P, C_P

    A = 0
    B = 0
    C = Y(1)
    D = X(1)

    !$OMP PARALLEL SHARED (X, Y, &
    !$OMP                  A, B, C, D, N) &
    !$OMP          PRIVATE(A_P, B_P, &
    !$OMP                  C_P, D_P)
    PRINT *, 'Parallel Section 1'
    !$OMP END PARALLEL

    !$OMP PARALLEL SHARED(X, Y, A, B, C, D, N) &
    !$OMP&         PRIVATE(A_P, B_P, C_P, D_P)
    PRINT *, 'Parallel Section 2'
    A_P = 0.0
    B_P = 0
    C_P = HUGE(C_P)
    D_P = -HUGE(D_P)

    !$OMP DO PRIVATE(I)
    DO I=1,N
        A_P = A_P + X(I)
        B_P = IEOR(B_P, Y(I))
        C_P = MIN(C_P, Y(I))
        IF (D_P < X(I)) D_P = X(I)
    END DO

    !$OMP CRITICAL
    A = A + A_P
    B = IEOR(B, B_P)
    C = MIN(C, C_P)
    D = MAX(D, D_P)
    !$OMP END CRITICAL
    !$OMP END PARALLEL
END SUBROUTINE REDUCTION2

function add1(a,b,fact) result(c)
!$omp declare simd(add1) uniform(fact)
    implicit none
    double precision :: a,b,fact, c
    c = a + b + fact
end function

function add2(a,b,i, fact) result(c)
!$omp declare simd(add2) uniform(a,b,fact) linear(i:1)
    implicit none
    integer          :: i
    double precision :: a(*),b(*),fact, c
    c = a(i) + b(i) + fact
end function

subroutine work(a, b, n )
    implicit none
    double precision           :: a(n),b(n), tmp
    integer                    :: n, i
    double precision, external :: add1, add2

    !$omp simd private(tmp)
    do i = 1,n
        tmp  = add1(a(i), b(i), 1.0d0)
        a(i) = add2(a,    b, i, 1.0d0) + tmp
        a(i) = a(i) + b(i) + 1.0d0
    end do
end subroutine

end module openmp_various_examples

module openmp_example_target_unstructured_data
  real(8), allocatable :: A(:)

  contains
    subroutine initialize(N)
      integer :: N

      print *, 'Maximum number of threads:', omp_get_num_threads()
      allocate(A(N))
      !$omp target enter data map(alloc:A)

    end subroutine initialize

    subroutine finalize()

      !$omp target exit data map(delete:A)
      deallocate(A)

    end subroutine finalize
end module openmp_example_target_unstructured_data
