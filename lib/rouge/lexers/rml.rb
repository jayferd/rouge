# -*- coding: utf-8 -*- #
# frozen_string_literal: true

module Rouge
    module Lexers
    class RML < RegexLexer
      title "RML"
      desc "A system agnostic domain specific language for runtime monitoring and verification"
      tag 'rml'
      filenames '*.rml'

      #keywords method
      def self.keywords
        @keywords ||= Set.new %w(
          matches not with empty all if else
        )
      end

      #arithmetic_keywords method
      def self.arithmetic_keywords
        @arithmetic_keywords ||= Set.new %w(
          abs sin cos tan min max
        )
      end

      #identifiers
      id_char = /[a-zA-Z0-9_]/
      uppercase_id = /[A-Z]#{id_char}*/
      lowercase_id = /[a-z]#{id_char}*/

      #other
      ellipsis = /(\.){3}/
      int = /[0-9]+/
      float = /#{int}\.#{int}/
      string = /'(\\'|[ a-zA-Z0-9_.])*'/

      #things to ignore
      whitespace = /[ \t\r\n]+/
      comment = /\/\/[^\r\n]*/

      #Note: Lexer States
      #One major element of the lexer is the collection of one or more states.
      #A state consists of one or more rules and a rule consists of a regular expression and an action (see description of rules below).
      #The action yields tokens and manipulates the state stack.

      #Note: The State Stack
      #The state stack represents an ordered sequence of states the lexer is currently processing.
      #States are added and removed from the "top" of the stack.
      #The oldest state is on the bottom of the stack and the newest state is on the top.
      #The initial (and therefore bottommost) state is the :root state.
      #The lexer works by looking at the rules that are in the state that is on top of the stack.
      #These are tried in order until a match is found.
      #At this point, the action defined in the rule is run, the head of the input stream is advanced,
      #and the process is repeated with the state that is now on top of the stack.

      #In this lexer the states can be seen as "contexts".
      #They are used to differentiate the Tokens which are matched by the same rules but in different contexts
      #For example, if we take the "eventypeId" and "evtypeVar" identifiers classes,
      #these two are matched by the same lexer rule.
      #However, they are differentiated by being defined in different contexts (states).
      #The lexer works with the rules defined in the current context. When it encounters a context switch,
      #it pushes a new state (context) on the stack and repeats the entire process.

      #Another example.
      #Considering grammar productions:
      #- expId ('<' expVar (',' expVar)...
      #- expId ('<' dataExp (',' dataExp)...
      #These productions can be matched by the same lexer rule:
      #a rule matching an expId followed by '<'.
      #This rule would be ambiguous if defined in only one state.
      #So the productions are differentiated by having the same rule but defined in different contexts (states)

      #Lexer states are also used to manage nested context in the grammar productions
      #For example, if inside an "exp" context the grammar production switches to a "dataExp" context,
      #a dataExp state is pushed onto the stack. Then the lexer hanldes the rules for the dataExp context,
      #and finally pops to the outer exp context.
      #Example:
      #grammar rule
      #            exp: IF ( dataExp )....
      #In this case, inside an exp context, when the lexer matches an IF followed by an oper bracket "(",
      #it pushes a dataExp state switching to its context, handles the rules for dataExp
      #and pops back to exp context.

      #Note: Rules
      #A simple rule takes:
      #1 a regular expression to match against;
      #2 a token to yield if the regular expression matches;
      #3 an optional new state to push onto the state stack if the regular expression matches.

      #A complex rule takes:
      #1 a regular expression to match against; and
      #2 a block to call if the regular expression matches.

      #Note: The order in which the rules are defined is crucial for the regex matching of the lexer.
      #For example, the rule matching "an identifier followed by an open bracket"
      #must be declared before the rule matching only "an identifier".
      #Otherwise, the rule matching "an identifier followed by an open bracket" would never be reached,
      #since the identifier before the bracket would always be captured by the other rule
      #
      #Another significant example in this lexer are the rules for the keywords.
      #These rules must be defined before the identifiers-matching rules, which would
      #otherwise capture all the keywords as identifiers.

      #Note: The HTML which is generated by Rouge is based on a list of token.
      #All Tokens yielded by the rules can be changed accordingly to the style that will be used
      #for a better visual result of the syntax highlighting
      #
      #For example, a Token yielded for a variable could intuitively be Name::Variable,
      #but this can be changed with any Token type that fits visually better.
      #For example it could be yielded Name::Entity if it fits better (bold font, different color,...)
      #The best way to choose the token to be yielded is using the visual examples
      #where is present also the list of tokens that Rouge supports

      #The following state is an auxiliary one containing rules shared between states
      state :whitespace_and_comments do
        #All whitespaces (also \t \r \n) are yielded as Text tokens
        rule %r/#{whitespace}/, Text
        #Comments are in-line text preceded by two slashes //
        rule %r/#{comment}/, Comment::Single
      end

      #The following root state handles the entry point of the grammar and the first production rule
      #specification: eventTypeDeclaration* equation EOF;
      #eventTypeDeclaration: declared=evtype NOT? MATCHES parents+=evtype ('|' parents+=evtype)* (WITH dataExp)? ';'
      #                    | evtype NOT? MATCHES eventExp (WITH dataExp)? ';'
      state :root do

        #The "mixin(state)" method mixes in the rules from another state into this state.
        #The rules from the mixed-in state will be tried in order before moving on to the rest of the rules in this state.
        mixin :whitespace_and_comments

        #A lowercase_id followed by an open par '(' is an evType with params
        #This rule must be defined before the rule matching only a lowercase_id,
        #otherwise this would never be matched
        #This complex rule regex captures two groups:
        #first group is a lowercase_id and second group is the open par '('.
        #The method 'groups' inside a rule block yields a Token Type for each captured group.
        #In this case:
        #group 1 -> lowercase_id -> Name::Function Token
        #group 2 -> open par '(' -> Operator Token
        #Then pushes an evTypeParam state on the stack to handle params of the evType
        rule %r/(#{lowercase_id})(\()/ do
          groups Name::Function, Operator
          push :evTypeParam
        end

        #Next complex rule matches a lowercase_id and stores the matched group in an array (|m|)
        #Note: in this case there is only one matched group, stored in m[0]
        #Then the lexer proceeds to compare the matched group with either keyords or identifiers
        #Since the rules are tried in the order they are defined, the rule matching an 'else'
        #must be defined before the one matching all the keywords
        #Following the grammar rules, after a "with" there is a dataExp -> ...(WITH dataExp)?...
        #A Keyword token is yielded and a dataExp state is pushed onto the stack

        #Other keywords are captured before any other identifier
        #and a Keyword token is yielded

        #It can be noticed that, since the definition order of the rules is relevant,
        #the rules capturing the identifiers are defined after the keyords rules.

        #Finally, if no keyords are matched, the lowercase_id is an evType identifier with no parameters

        rule %r/#{lowercase_id}/ do |m|
        #in this case there is only one matched group, stored in m[0]
          if m[0] == 'with'
            token Keyword
            push :dataExp
          elsif self.class.keywords.include? m[0]
            token Keyword
          #if no keyords are matched, it's an identifier
          else
            token Name::Function
          end
        end

        #Next rule checks if an eventExp is inside () [] {} brackets
        #like (eventExp... | {eventExp... |[eventExp...
        #for example : ...matches {event:'func_pre',name:'my_insert'...
        #The rule captures the group of an open bracket -> '(', '{' or '[',
        #then yields an Operator Token for the bracket and pushes an evTypeParam state to handle the eventExp
        #
        #Since the evTypeParam production rule in the grammar is the following
        #evTypeParam: evtypeVar
        #           | dataExp
        #           | eventExp,
        #the evTypeParam state handles the syntax highlightning rules which are
        #in common with the three evTypeParam productions
        #
        #In this case the state evTypeParam is pushed to handle the eventExp inside brackets
        rule %r/\(|\{|\[/, Operator, :evTypeParam

        #An uppercase_id is an expId for a possibly generic expression
        #This rule yields a Token for the expId and pushes an 'equation_blockExp' state
        rule %r/#{uppercase_id}/, Name::Class, :equation_blockExp

        #Finally the next rules check if an eventExp is a string, int, float or boolean
        #and yields the corresponding Token type
        rule %r/#{string}/, Literal::String
        rule %r/#{float}/, Num::Float
        rule %r/#{int}/, Num::Integer
        rule %r/(true|false)\b/, Keyword::Type

        #In root state there are only '|' and ';' operators, as it can
        #be seen in the eventTypeDeclaration production rule of the grammar
        rule %r/[\|;]/, Operator

        #end root state
      end

      #The evTypeParam state handles the syntax highlighting rules which are
      #in common with the three productions of the evTypeParam grammar rule:
      #evTypeParam: evtypeVar
      #           | dataExp
      #           | eventExp
      state :evTypeParam do

        mixin :whitespace_and_comments

        #The next rules check if an evTypeParam is a string, int, float
        #and yield the corresponding Token type
        rule %r/#{string}/, Literal::String
        rule %r/#{float}/, Num::Float
        rule %r/#{int}/, Num::Integer

        #A lowercase_id followed by a ':' is a fieldkey
        #grammar rule-> field: fieldkey ':' eventExp
        #The (?=:) used in the regex is the 'positive lookahead'
        #It checks if a lowercase_id is followed by ':' whithout consuming the : token
        #The rules yields a token for the fieldkey
        #The ':' token is instead matched and yielded in the operators rule
        rule %r/#{lowercase_id}(?=:)/, Name::Entity

        #Next complex rule matches a lowercase_id and stores the matched group in an array
        #Note: in this case there is only one matched group, stored in m[0]
        #Then the lexer checks if the matched lowercase_id is a boolean, a keyord or finally an evtypeVar

        rule %r/(#{lowercase_id})/ do |m|
          if m[0] == 'false' || m[0] == 'true'
            token Keyword::Type
          elsif self.class.keywords.include? m[0]
            token Keyword
          else
          #A lowercase_id in this state is an evtypeVar
          #(the Literal::String::Regex Token is yielded for stylistic reasons)
            token Literal::String::Regex
          end
        end


        #The next two rules handles the nested states when an open or closed bracket (){}[] is matched
        #This way, the following grammar rules can be managed
        #eventExp: '{' (field (',' field)*)? '}'
        #        | '(' eventExp ')'
        #        | listEventExp : '[' ']'
        #                        | '[' ELLIPSIS ']'
        #                        | '[' eventExp (',' eventExp)* (',' ELLIPSIS)? ']'
        #If there is an open bracket, a nested state (of the current state) is pushed
        #
        #Calling push without params pushes dynamically the current state
        rule %r/\(|\{|\[/, Operator, :push
        #If there is a closed bracket, one inner state is popped
        rule %r/\)|\}|\]/, Operator, :pop!

        #rules for ellipsis and operators
        rule %r/#{ellipsis}/, Literal::String::Symbol
        rule %r/[*&%!+\/\\_\|=:,;<>\^-]/, Operator

        #end evTypeParam state
      end

      #equation_blockExp state handles the following productions:
      #(after matching an expId) -> ('<' expVar (',' expVar)* '>')? '=' exp
      #Note: if expId is not generic (for example CheckElem = not_insert* {let....)
      #      the lexer in this state simply ignores the first rules and matches only the '=' token
      #This state also handles the evtypeVar style class inside the grammar rule:
      #exp: DEC evtypeVar (',' evtypeVar)* ';'
      #These two grammar rules share the same style class

      state :equation_blockExp do

        mixin :whitespace_and_comments
        #matches the '>',',' and '<' operators
        rule %r/[<,>]/, Operator

        #A lowercase_id in this state is an expVar or evtypeVar, they share the same style class
        #(the Literal::String::Regex Token is yielded for stylistic reasons)
        rule %r/#{lowercase_id}/, Literal::String::Regex

        #At this point, if the lexer matches the '=' token,
        #(being in ('<' expVar (',' expVar)* '>')? '=' exp) production,
        #it should pop in the root state (the outer state of exp is root),
        #and in the root state it should handle this event and push an exp state.
        #
        #However in this case the 'goto' method is used, which has the same behaviour.
        #The method replaces the current head of the stack with the state given
        #In this case |goto :exp| <=> |pop, (root state)-> push :exp|
        rule %r(=) do
          token Operator
          goto :exp
        end

        #next rule is for popping back to exp
        #coming from exp: DEC evtypeVar (, evtypeVar)* ;
        rule %r/;/, Operator, :pop!

      #end equation_blockExp state
      end

     #State exp for specification expression
      state :exp do
        mixin :whitespace_and_comments

        #The 'if' keyword is matched before other keywords to handle the grammar rule
        #exp: IF '(' dataExp ')'...
        #The rule matches two groups, the first is 'if' keyword and second is open par '('
        #It yields a Keyword token for 'if' and an Operator token for open par '('
        #Then it pushes a dataExp state to handle dataExp inside par
        rule %r/(if)(\()/ do
          groups Keyword, Operator
          push :dataExp
        end

        #The next rule handles the production:
        #exp: {DEC evtypeVar (',' evtypeVar)* ';'
        #The evtypeVar tokens are of a different style class from other identifiers in this state
        #For this reason, another state (equation_blockExp) is used for handling evtypeVar declaration
        #In this rule a Keyword token for 'let' or 'var' is yielded and a equation_blockExp state is pushed
        rule %r/(?:let|var)\b/, Keyword, :equation_blockExp

        #In this state a lowercase_id followed by an open par '(' is an evType with params
        #This complex rule captures two groups:
        #first group is a lowercase_id and second group is the open par '('.
        #In this case:
        #group 1 -> lowercase_id -> Name::Function Token
        #group 2 -> open par '(' -> Operator Token
        #Then pushes an evTypeParam state to handle params of the evType
        rule %r/(#{lowercase_id})(\()/ do
          groups Name::Function, Operator
          push :evTypeParam
        end

        rule %r/(#{lowercase_id})/ do |m|
          if self.class.keywords.include? m[0]
            token Keyword
          else
          #A lowercase_id not followed by an open par '(' is an evType with no params
            token Name::Function
          end
        end

        #The next rule handles the production:
        #expId ('<' dataExp (',' dataExp)* '>')?
        #In this case if an uppercase_id (expId) is followed by a '<' token,
        #a dataExp state is pushed to handle the dataExp inside <...>
        rule %r/#{uppercase_id}(?=<)/, Name::Class, :dataExp

        #If the uppercase_id is not followed by '<', it is an expId non generic
        #no need to change state
        rule %r/#{uppercase_id}/, Name::Class

        #rule for operators
        rule %r/[()*+\/\\_\|=,{}!<>?-]/, Operator

        #The ';' is the end of the exp state, popping to root state.
        rule %r/;/, Operator, :pop!

        #end exp state
      end

      #DataExp state for boolean and arithmetic expressions
      state :dataExp do

        mixin :whitespace_and_comments

        #Checks if a lowercase_id is a boolean, arithmetic keyord or a variable
        rule %r/#{lowercase_id}/ do |m|
          if m[0] == 'true' || m[0] == 'false'
            token Keyword::Type
          elsif self.class.arithmetic_keywords.include? m[0]
            token Keyword
          else
          #A lowercase_id in this state is an evtypeVar
          #(the Literal::String::Regex Token is yielded for stylistic reasons)
            token Literal::String::Regex
          end
        end

        #The next rules handle the production for nested dataExp
        #dataExpexp: '(' dataExp ')', or ABS|SIN|COS|...'(' dataExp ')'
        #If an open par is matched, it pushes a nested state (of the current state)
        rule %r/\(/, Operator, :push
        #If a closed par is matched, it pops to outer state
        rule %r/\)/, Operator, :pop!

        #Next rule is for differentiate the '>' token as binary operator
        #in the production: dataExp '>' dataExp # greaterThanDataExp
        #and in the production dataExp '>=' dataExp # greaterThanEqualToDataExp
        #from the same token '>' in the grammar rule: expId ('<' dataExp (',' dataExp)* '>')?
        #
        #If the operator '>' is not followed by a dataExp,
        #it means that it is the token closing the brackets in '<' dataExp (',' dataExp)* '>'
        #and it pops to outer state
        #
        #The (?!pattern) used in the regex is the negative lookahead
        #it checks if a '>' is NOT followed by pattern. In this case
        #pattern is the regex for a dataExp
        #
        #first check if > is followed by else keyword and it pops
        rule %r/>(?=\s*else)/, Operator, :pop!
        #if followed by an evtypeVar state is not changed
        #it also checks that it is an evtypeVar and not an evType with params
        rule %r/>(?=\s*#{lowercase_id}(?!\())/, Operator
        #if not followed by a dataExp, it pops
        rule %r/>(?!\s*(=|abs|sin|cos|tan|min|max|true|false|
                    #{float}|#{int}|-|\())/, Operator, :pop!

        #rules for operators and numbers
        rule %r/[*^?!%&\[\]<>\|+=:,.\/\\_-]/, Operator
        rule %r/#{float}/, Num::Float
        rule %r/#{int}/, Num::Integer

        #The ';' operator is the end of dataExp state and pops to outer state
        rule %r/;/, Operator, :pop!
      end
    end
   end
 end
